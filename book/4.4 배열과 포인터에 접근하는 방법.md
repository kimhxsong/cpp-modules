```
		x  =  y
<l-value>     <r-value>
```

l-값:
- 컴파일 타임에 알려진다
- 결과를 저장할 위치를 알려 준다.

r-값:
- 주소에 들어 있는 내용
- 런타임까지 알 수 없다.
- 별로도 명시하지 않는 한 'y의 값'은 r-값을 의미한다.


'수정 가능한 l-값'은 C 언어가 도입한 용어로, l-값은 대입문 왼쪽에 표시하도록 허용한 값을 뜻한다.

l-값으로 배열 이름을 나타내기 위해 도입.... 했지만, 문제는 C에서는 배열 이름이 할당되지 않은 상태일 수도 있다는 것이다. 즉, 배열 이름은 l-값이지만 '수정 가능한 l-값'은 아니라는 것.

알기 쉽게 표현하면 -> 오직 변경할 수 있는 것만 대입할 수 있다.

l-value
- 이 주소는 컴파일 타임에 알게 되며 런타임에 변수가 유지되는 곳.

r-value
- 런타임까지 알 수 없으며, 변수에 저장된 값이 필요할 경우, 컴파일러는 주어진 주소에 들어 있는 값을 읽어 지스터에 저장하는 코드들 내보낸다.

*요점!: 각 심벌의 주소가 컴파일 타임에 알려진다는 것.*

```c
char a[9] = "abcdefgh";

컴파일러 심벌 테이블에 a의 주소로 9980을 등록한다.
	런타임 단계1: i값을 얻은 후 그 값을 9980에 더한다.
	런타임 단계2: 주소(9980+i)에 들어 있는 내용을 가져온다.

  |   |   |   |   |   |   |
9980 +1  +2  +3  +4  +5  +6

4-2 배열 참조 과정
```

이것이 `extern char a[]`;나 `extern char a[100];`이 동일한 이유다.
이 두 선언은 a는 배열, 다시 말에 a는 char타입의 메모리 주소라는 것을 가리킨다.

반대로 `extern char * p;`   라고 선언하면 p는 포인터이며, 가리키는 객체는 char라는 것을 컴파일러에 알려 준다. 그래서 문자를 얻기 위해서는 주소 p에 있는 값을 가져온 다음, 그 값을 주소로 사용하여 해당 주소에 있는 내용을 가져오면 된다. 포인터 접근은 훨씬 유연하지만 추가 참조를 위한 CPU 연산이 필요하다.

```c
char *p         .  .  . c = *p;

컴파일러 심벌 테이블에 p의 주소로 4624를 등록한다.
	런타임 단계1: 주소 4624에 들어 있는 내용을 가져온 후 그 값이 '5081'이라고 알려 준다.
	런타임 단계2: 주소 5081에 들어 있는 내용을 가져온다.

      5   |   0   |   8   |   1
 -->4624
                            ---> |5081|
4-3 포인터 참조 과정 (간접참조)
```

아래의 두 방식 모두 같은 결과인 d를 얻는다.
- `char * p = "abcdefgh;"` ... p[3]  //char에 대한 포인터라고 컴파일러에 알려 줬다.
- `char a[] = "abcdefgh;"` ... a[3] //a가 char로 구성된 시퀀스

그러나 과정이 완전히 다르다.

`extern char *p`라고 선언한 다음 p[3]과 같이 참조하면 4-2 + 4-2을 조합한 것이 된다.
컴파일러는 다음과 같은 코드를 생성한다.
1. p의 주소를 가져와 해당 주소의 포인터값을 조회한다.
2. 첨자가 나타내는 오프셋을 포인터 값에 더한다.
3. 결과로 만들어진 주소에 접근한다.

p[i] 참조의 뜻은 'p가 가리키는 곳부터 시작해 i개만큼 더 나아가는데, 이때 개수 단위는 char(1바이트)다'라는 것을 의미한다.

앞에서 p를 포인터로 '선언'했기 때문에 p를 원래부터 포인터로 '정의'했는지와 관계없이 포인터 방식으로 참조한다. `char p[10];`으로 정의하고 `extern char *p;`로 외부 선언한 경우를 생각해보면... p[i]의 내용을 검색하면 문자를 얻기는 하지만 문제는 그것을 포인터로 취급한다는 것.
- 아스키 문자를 주소로 해석하는 것은 이미 재앙
- 운이 좋다면 코어 덤프.
- 최악의 경우 주소 공간 어딘가를 엉뚱한 내용으로 덮어쓰거나 프로그램이 원인 모를 오류에 빠질 수 있다.