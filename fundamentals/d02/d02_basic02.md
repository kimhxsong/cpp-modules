#ad-hoc_polymorphism #operator_overload #canonical_form #conclusion 

Peek declaration

go to definition

go to declaration

고정소수점

Orthodox Canonical Form?

Floating Point Number vs Fixed Point Number

namespace는 중괄호 안에

자료형

![[Pasted image 20220315174532.png]]

부동소수점에 f를 붙이지 않으면 double
double -> float => Error: truncation

initialization
- copy intialization
- direct initialization
- uniform initializaion

uniform initialization은 초기화를 알맞지 않은 범위의 수를 쓰면 "error"가 나게 된다.

ERROR
- int i = 3.14

 CASTING
 - int i = (int)3.14

enum vs enum class

멤버함수 호출 '괄호'

고정너비 정수

c++11
자료형
- 고정너비 정수 // 멀티 플랫폼 프로그래밍
- enum 클래스


부동소수점 vs 불리언
메모리에서 CPU로 보낼때도 마찬가지라 float가 나음.

numeric_limits<float>::lowest, 


//switch-case
switch(평가할 표현식)

표현식의 값은 정수로만.

float 값을 넣을 수는 없엉.

for (초기식; 조건식; 제어식)
{
}

do while X

endl은 조금 고민됨.


rand()를 호출하기 전에

srand(time(0));  // 시드 설정
rand()와 짝꿍

rand(); 는 보통 0~32767 정도의 숫자.

원하는 숫자..

randIO % (원하는 숫자 + 1)

라벨은 블럭과 동일선상

percentage 계산할 때
wins/ total \* 100 고치기

정수로 계산(소수점이 필요없는 경우)
100 * wins / total

또는 플로트 자료형 이용.

열거형

관리차원에서 좋지 않다.

const int .. 상수

// 상수인건 알겠는데, 너무 따로 따로 노는 느낌?
// 하나의 셋트인데?

enum 네이밍 규칙에 대해서 고려해보자. 겹치지 않도록 
이를 방지하기위해  C++에서는 enum class를 지원한다.

auto는 나중에..

컴파일러가 전역에 const int a,, 스택에 안올리고 전처리처리할 수도,,
enum은 데이터가 주소값에 저장되어 있어.

전처리

// #이 붙은 것 -> 전처리 지시문.
// 프로그램 빌드 과정.
// 디버깅, 문제의 경우 컴파일 단계에서 발견할 수 없어..

상수는 절대 매크로 잘안씀.

enum 짱.


함수 또는 함수의 다른 이름:프로시저, 메소드, 루틴

함수어카징..

검색: 스택프레임

디버그도구
{
프로시저 단위 실행 (어셈블리 인스트럭션 처럼)
한 단계식 코드 실행
프로시저 나가기
}

스택프레임, 
TCP

매개변수로 전해진 인자값의 주소와, 스택프레임의 주소는 어떻게 다를까.

ret 나  돌아가겠다

왜 터졌는지 알수있으려면.

data
{
//초기화나 상수 여부에 따라 조금식 달라질 수 있음
	.rodata
	.data
	.bss
}

자유도가 높으면 누가 실수했는지 파악하기 어려워진다.

하나의 스택프레임
매개변수
지역변수
반환값

함수 선언 ,, -> 현재 스택프레임에 다음 함수를 콜하기 전에 값을 준비해야하기 때문에 알아야함. 데이터의 크기를 알아야 한다.

호출스택이 앞으로의 인생에 많은 도움이 된다.

오버로딩 (함수 중복 정의 : 함수 이름의 재사용)
- 매개변수 갯수가 다르거나
- 매개변수 타입이 다르너가.

반환 형식으로만 구분되는 함수를 오버로드할 수 없다.

재귀적으로 만들다보면 스택오버플로우 발생할 수도 있다.
예외처리를 추가하거나, 반복문으로 변환하던가.

포인터.. 타입의 불일지? 주소를 저장하는 바구니 4or8바이트 고정 크기

casting 잘못하다가 덮어씌어줘.

int num
int *ptr = &num;
___int64*ptr ptr2 = (__int64)&number;

포인터 연산
- 주소 연산자 &
- + 포인터의 크기만큼 이동
- 간접 연산자
- 간접 멤버 연산자 (->) (*this). 


구조체끼리 복사할 때 무슨 일이 벌어질까?
하나씩 복사.

로우레벨 관점에서 레퍼런스는 똑같암
레퍼런스는 선언과 동시에 초기화 되어야함.

값전달처럼 편리하게 사용하고.
주소 전달처럼 주소값을 이용해서 건드리는.

하이레벨 관점에서는 굳굳.
사용하는 인터페이스가 다르다.

포인터 vs 참조 세기의 대결?
성능 : 똑같음
편의성 : 참조.


1) 편의성이 좋다는게 꼭 장점만은 아니다.

2) const를 사용해서 이런 마음대로 고치는 부분 개선 가능.

레퍼런스 어지간해서는 const와 같이 사용.

포인터 * 기준으로 const 가 앞에 있냐 뒤에있냐에 따라서 결과가 다름.

info가 가리키는 주소값을 변경하나
info가 가지키는 주소값이 가리키고 있는 값을 변경할 수 없거나.

레퍼런스 사용하면.. 안전성에 대해 좀 더 고려.


2) 초기화 여부  -> 참조하는 대상이 없으면 안됨.
3) 포인터 -> 대상이 실존하지 않을 수도 있음.
4) nullptr 추천하는 방식. 어떠한 주소도 가리키지 않음을 표시하고 싶을때 nullptr사용하는 것을 추천한당.

구글에서 만든 오픈소스를 보면 거의 무조건 포인터 사용
언리얼 엔진에선 reference도 애용

Rokiss 선호 스타일
- 없는 경우도 고려해야 한다면  pointer (null 체크 필수)
- 바뀌지 않고 읽는 용도 (readonly)만 사용마하면 const ref&
- 단, 다른 사람이 pointer를 만들어 놓은걸 이어서 만든다면, 계속 pointer를 사용한다.

readonly라면 const ref&추천

#define OUT 바뀔수도 있는 힌트.


VC에서는 배열의 크기는 상수여야 함.

배열 초기화 

int number[5] = {} // 특별히 빠른건아니구. 가독성

int numbers[5] = {}

Cstyle 문자열 nul문자.


const char * test1 = "Hello World"; - sizeof()
char test2[] = "Hello World"; - sizeof() 크기 각각 달라.

차이가 무엇인가?

char test2[] = "Hello World";

배열은 함수 인자로 넘기면, 컴파일러가 알아서 포인터로 치환한다.
char[] -> char *

dx, dy에 대한 배열을 미리 만들어.

프로시저 오리엔티드 함수
절차지향 함수지향. - 확장성 약점.

//데이터 + 가공(로직, 동작)

//

함수접기?

객체 만들어

instantiate.

클래스 멤버변수만 데이터에.
// lea = load effective address

자기자신을 가리키고 싶으면 "this"
this->생략.

생성자 - > 여러개 존재 가능
끝 -> 소멸자 (오직 하나.)

[1] 기본 생성자 (인자가 없음)

[2] 복사 생성자 (자기 자신의 클래스 참조 타임을 인자로 받음) - 도플갱어.
{
	(const Knight & knight)
}

[3] 기타 생성자.


// 암시적 생성자.
// 생성자를 명시적으로 만들지 않으면,
// 아무 인자도 받지 않는 [기본 생성자]가 컴파일러에 의해 자동으로 만들어짐.
그러나 우리가 명시적으로 아무 생성자가 만들면
자동으로 만들어지던 기본 생성자는 더이상 만들어지지 않는다.

Implicit vs Explicit

Default로 생성되는 것들이 무엇인지.?

생성자로 초기화
Knight k2(k1); // 복사 생성자
Knight k3 = k1; 초기화 // 복사 생성자

단순복사
Knight k4; // 생성자
k4 = k1;  // 복사


이 중에서 인자를 1개만 받은 [기타 생성자]를 [타입 변환 생성자]라고 부르기도 함.


암시적 형변환

int num = 1;
float fnum = (float)num; // 명시적
double d = num // 암시적 - 별말 안했는데 컴파일러가 알아서 처리하고 있음.

Knight k5;
k5 = 1; // Knight(int hp)를 호출함 ㄷ ,,
HelloKnight(5).. => HelloKnight(knight(5)); 와 동일하게 처리됨.

타입 변환 생성자는 명시적인 용도로만 사용할 것 !

private 변수같은건 structure로 묶어낼 수 있을 것 같다.
클래스 함수는 어떻게 묶어줄 수 있을까? =>  상속

// 메모리
[  [ Play]  ]
[  Knight  ]

부모님 유산. 

아래의 문법은 사용할 수 있지만 프로그래머 인생에서 사용해본 적 없어.
- k.Player::Move(); 

Knight를 생성하면 -> Player의 생성자? Knight의 생성자?
-> 솔로몬의 선택 -> 둘다 선택.

부모님 생성자
자식 생성자
자식 소멸자
부모님 소멸자

정확히. 자식의 선처리 영역에서 부모의 생성자를 호출. 그래서 먼저
호출된 것처럼 보여.

엄밀히는 자식의 생성자 호출 바로 이전에 부모님의 생성자를 호출..

자식의 소멸자 후처리 영역에 부모 소멸자 호출.

생성자에서.

생성자 선언: 부모(생성자 선택)
{

}

오늘의 주제 : 은닉성


OOP 
- 상속성
- 은닉성
- 다형성

은닉성(Data Hiding) = 캡슐화(Encapsulation)
숨기는 이유?
- 1. 정말 위험하고 건드리면 안되는 경우
- 2. 다른 경로로 접근하길 원하는 경우 (캡슐화)

접근 지정자
- public, protected, private

protected - 상속에는 사용가능.

상속 접근 지정자.

캡슐화
연관된 데이터와 함수를 논리적으로 묶어놓은 것.

setXXXX()
{
	내부에 제어구조.
}

set함수 내에서 분기문을 넣지 말지 고민이 들었는데, 묶어주는게 훨씬 나은 것 같다.

상속 접근 지정자
다음 세대한테 부모님의 유산을 어떻게 물려줄지?
부모님한테 물려받은 유산을 꼭 나의 자손들한테도 똑같이 물려줘.
public -> 부모님의 유산 설계 그대로
protected -> 자손들에게만.
private -> 상속은 이제 그만.
생략하면 private이 디폴트임.

상속받은 자식의 변수는 어떻게?

대부분 public, 드물게 private이 활용됨.


다형성 = 겉은 똑같은데, 기능이 다르게 동작한다.
- 오버로딩 = 함수 중복 정의 = 함수 이름의 재사용
- 오버라이딩 = 재정의 = 부모 클래스의 함수를 자식 클래스에서 재정의
- 

자식 -> 부모로 넘어가는건 되지만
부모 -> 자식으로 넘어가는건 글쎄


Player p;
MovePlayer(&p); // 플레이어는 플레이어다? YES
MoveKnight(&p); // 플레이어는 기사다? NO

Knight k;
MoveKnight(&k); // 기사는 기사다? YES
MovePlayer(&k); // 기사는 플레이어다? YES

기능을 묶을 수 있어 매우 좋아...


// 바인딩(Binding) = 묶는다.
// - 정적 바인딩(Static Binding) : 컴파일 시점에 결정
// - 동적 바인딩(Dynamic Binding) : 실행 시점에 결정

일반 함수는 정적바인딩으로 묶여 있어.

동적바인딩 어떻게 하냐?? -> 가상 함수 (virtual function)

부모에서 virtual키워드로 선언된 함수는 자식에서 재정의를 하더라도 가상 함수다.

동적함수는 

virtual을 붙여준 함수는 어떻게 동작하는걸까?

메모리를 까서 살펴보자.

실제 객체가 어떤 타입인지 어떻게 알고 알아서 가상함수를 호출해준걸까?
- 가상 함수 테이블 virtual function table

[VMove] [VDie]

가상함수테이블은 누가만드나.

생성자의 선처리 영역에서 만들어진다.

원본 객체에 따라 다르게 동작시키고 싶을 때.

순수 가상 함수 : 구현은 없고 '인터페이스'만 전달하는 용도로 사용하고 싶을 경우
가상함수 = 0; 을 붙인다.

<C++11>
abstract;

추상클래스 : 순수 가상 함수가 1개 이상 포함되면 바로 추상 클래스로 간주
- 직접적으로 객체를 만들 수 없게 됨
섹션3 ~ 섹션6.다형형#2까지 봤음.

기드라 책 사고싶당.


초기기화 리스트
- 일반 사아속 관계에서 원하는 부모 생성자 호출할 때 필요하다.
- 생성자 내에서 초기화 vs 초기화 리스트
-- 일반 변수는 별 차이 없음
-- 멤버 타입이 클래스인 경우 차이가 난다

클래스를 설계할 때 고려할 점.
// IS-A? 기사는 플레이어다? -> OK 상속관계
// HAS-A? 플레이어는 인벤토리다? -> X, 플레이어는 인벤토리를 포함하고 있다. -> OK 포함관계

상속받은 클래스를 호출하면서 멤버변수 멤버객체를 덮어쓸 수 있다. 그러니 블럭보다는 초기화리스트를 이용하는 것이 나쁘지 않은 선택

초기화를 하는 부분은 길어지더라도 블럭보다는 초기화

연산자 오버로딩(Operating Overloading)

연산자 vs 함수

연산자는 피연산자의 개수/타입이 고정되어 있음.

연산자 오버로딩?
[연산자 함수]를 정의해야 함.
함수도 멤버함수 vs 전역함수가 존재하는 것처럼, 연산자 함수도 두가지 방식으로 만들 수 있음.

RET operator{{연산자}}(ARG_LIST)
{
	필요에 따라 임시 객체 생성. 
}

Position operator+(const Position& arg)
{
	Position pos;
	pos._x = _x + arg._x;
	pos._y = _y + arg_y;
}


pos3 = pos + pos2;
pos3 = pos.operator+(pos2);

- 멤버 연산자 함수 version
-- a op b 형태에서 왼쪽으로 기준으로 실행됨. a가 클래스여야 가능. a를 기준 피연산자라고 한다.
-- a 가 클래스가 아니면 불가능. // b op a 불가능. 

- 전역 연산자 함수 version
Position operator+(int a, const Position& b)

? ==

bool operator==(const Position& arg);...

클래스끼리 비교하는 일이 종종 생긴다.

그럼 무엇이 더 좋은가? 그런거 없음. 심지어 둘 중 하나만 지원하는 경우도 있기 때문.
- 대표적으로 대입 연산자는 전역 연산자 함수로 재정의할 수 없다.

=을 재정의 할 때는 자기 자신의 참조값을 리턴하는 경우가 많다.

Position& operator=(int arg)
{

}

모든 연산자를 다 오버로딩 할 수 있는 것은 아니다(:: . .* 이런건 안됨)
모든 연산자가 다 2개 항이 있는 것 아님. ++ --가 대표적(단항 연산자).
전위형 (++a) operator++()
후위형 (a++) operator++(int)

단항연산자도 마찬가지로 자기 자신의 참조값을 리턴하도록 만드는 것을 추천한다.

struct는 그냥 구조체 (데이터 묶음)
class oop특징을 살펴보자.

static .. 변수. 설계도상으로만 존재하구. 밖에 존재한다고 생각해야.
어떤 메모리?
초기화 하면 .data
초기화 안하면 .bss

스태틱 변수에 s prefix를 붙인당.

static 키워드 만들면. 함수 내부에 만들어도 . data영역에 잡힌다.

스태틱 변수: 프로그램 시작/종료(메모리에 항상 올라가 있음)
가시범위는 파일 또는 블럭에 한정적.


동적 할당

메모리 구조 복습
- 실행할 코드가 저장되는 영역 -> 코드 영역
- 전역/ 정적 변수-> 데이터 영어
- 지역 변수/매개 변수 -> 스택 영역
- 동적 할당 -> 힙 영역

스택 영역
// 함수가 끝나면 같이 정리되는 불안정한 메모리
// 잠시 함수에 매개변수 넘기거나, 하는 용도로는 OK

// C++에서는 기본적으로 CRT(C런타임 라이브러리)의 힙 관리자를 통해 힙 영역 사용
단, 정말 원한다면 우리가 직접 API를 통해 집을 생성하고 관리할 수도 있음.

malloc . 메모리 부족 NULL..

void *? 
타고 가면 뭐가 있는지 모르겠으니까 너가 적당히 변환해서 사용해라.
double free crash.

Use-After-Free.
- 프로그래머 입장: OMG
- 해커 입장 : 프로그램 제어를 건드릴 수 있다: 오에..

타입에 상관없이 특정한 크기의 메모리 영역을 할당받으려면? -> malloc/free

new/delete는 (생성 타입이 클래스일 경우) 생성자/소명자를 호출해준다.

c++버그.. 동적할당과 관련된 부분이 많아.

타입변환
- 값 타입 변환
- 참조 타입 변환


안전도 분류
- 안전한 변환
	- 같은 타입이면서 크기만 더 큰 자료형
- 불완전한 변환
	- 의미가 항상 100%일치한다고 보장하지 못하는 경우
	- 

프로그래머 의도에 따라 분류

[1] 암시적 변환
특징) 이미 알려진 타입 변환 규칙에 따라서 컴파일러 '자동'으로 타입 변환

[2] 명시적 변환
int a = 12345678
int *b = (int*)a;


아무런 연관 관계가 없는 클래스 사이의 변환.

[1] 연관없는 클래스 사이의 '값 타입' 변환..
특징) 일반적으로 안됨.


타입 변환 생성자
// 완전 다른
Dog(const Knight& knight) {};
operator Knight()
{
	return (Knight*)(*this);
}

Knight knight;
Dog dog = (Dog)knight;

//타입 변환 연산자
operator Knight()
{
	return (Knight)(*this);
}

[2] 연관없는 클래스 사이의 참조 타입 변환.
Knight knight;
Dog& dog = (Dog&)knight;
dog._cutness = 12;

//static_cast(knight) ? 이거 키워드 머임..


상속 관계에 있는 클래스 사이의 변환

[1] 상속 관계 클래스의 값 타입 변환

자식 -> 부모 OK / 부모 -> 자식 NO

결론
[값 타입 변환] : 진짜 


매개변수... 포인터나 참조자로 넘겨주는게 아니라면 매개변수 객체를 생성하게 되므로 생성자가 호출됨.

상속 관계에서 소멸자 호출..

[결론]
- 포인터 vs 일반 타입 : 차이를 이해하자
- 포인터 사이의 타입 변환(캐스팅)을 할 때는 매우 매우 조심해야 한다!
- 부모-자식 관계에서 부모 클래스의 소멸자에는 까먹지 말고 virtual


기본 생성자.

복사 생성자. + 복사 대입 연산자. : 둘 다 안 만들어주면 컴파일러 '암시적으로' 만들어 준다.
 


얕은 복사
// 멤버 데이터를 비트열 단위로 '똑같이' 복사 (메모리 영역 값을 그대로 복사)

// Stack : Knight [hp 0x1000 ] -> Heap 0x1000 Pet[   ]


복사 생성자로 만들어진 객체를 delete하면 상속받은 객체까지 소멸자가 호출될 수 있음. 더블 프리 문제.
생성자를 각각 정의.

Knight(const Kngith& knight)
{
	_hp = knight._hp;
	_pet = new Pet(*knight._pet) // 깊은 복사.
}

암시적 복사 생성자 스텝
1. 부모 클래스의 복사 생성자 호출
2. 멤버 클래스의 복사 생성사 호출
3. 멤버가 기본 타입일 경우 메모리 복사

명시적 복사 생성자 스텝
1. 부모 클래스의 기본 생성자 호출
2. 멤버 클래스의 기본 생성자 호출

암시적 복사 대입 연산자
- 암시적 복사 생성자와 비슷.

명시적 복사 대입 연산자
1. 모든 걸 알아서.

Knight(const Knight& knight) : Player(knight), _pet(knight._pet)


명시적으로 만들어주는 순간 모든 복사의 책임은 자신이 진다.

기본적으로 얇은 복사.

,,,,,,


멤버 변수를 새롭게 추가할 때 생성자, 소멸자에서 새로 추가한 멤버 변수에 대한 처리가 필요한지 판단할 필요가 있다.


캐스팅 4총사

1. static_cast // 타입 원칙에 비춰볼 때 상식적인 캐스팅만 허용해준다.  -- 빈번하게 사용.
	1. int <-> float
	2. Player*-> Knight* (다운 캐스팅) // 안정성 보장 못함.
		- ex1. float ratio = static_cast<float>(hp) / maxHp;
		- ex2. Knight* k = new Knight();, Player* p2 = static_cast<Player*>(k);
		// 원본 자체가 Knight인지 아닌지 알 수 없어.
			- 캐스트 전에 원본에 대한 확인을 필요?

2. dynamic_cast: 상속 관계에서의 안전 형변환
	- RTTI(RunTime Type Information)
	- 다형성을 활용하는 방식.
	- virtual keyword 필수.
	- 만약 잘못된 타입으로 캐스팅을 했으면, nullptr 반환
	- static 보단 느리겠져..
	- 소멸자를 virtual?

3. const_cast
	- const를 붙이거나 떼거나,,,

4. reinterpret_cast : 다시-간주하다/생각하다. // 
- 포인터랑 전혀 관계없는 다른 타입 변환 등
- ex0. __int64 *address = reinterpret_cast<__int64>(k2);

void* p = malloc(1000);
이런 경우.
Dog* dog2 = p;

c style의 타입변환은 이제 잊으셔야..

어떤 상황에서 전방선언 해야하는지 어떤 상황에서 헤더로 관리해야하는지 고민해봐야

코드 흐름 제어.

시작 프로젝트로 설정.
프로젝트 끼리 이동하는 기능.

여러 개의 시작 프로젝트 --.